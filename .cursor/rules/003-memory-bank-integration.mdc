---
description: Logic behind implementation of AI Memory's MCP
globs:
alwaysApply: false
---
# Memory Bank Integration Rules

## MCP Server Development

### Protocol Implementation ‚úÖ
- **MCP SDK Version**: @modelcontextprotocol/sdk ^1.12.1 (validated in production)
- **Transport**: stdio transport for Cursor 0.50+ compatibility (proven stable)
- **JSON-RPC**: Proper error codes and structured responses implemented
- **Server Architecture**: Single consolidated MCP implementation with shared utilities

### Core Service Architecture ‚úÖ
```typescript
// Proven pattern in use:
export class MemoryBankServiceCore implements MemoryBank {
  constructor(
    memoryBankPath: string,
    logger: Logger,
    /**
     * Cache/streaming layers are retained in code for future scalability but **disabled by default**
     * because typical memory-bank files are small (<5 KB). They can be stubbed with no-op
     * implementations in production builds.
     */
    cacheManager: CacheManager | undefined,
    streamingManager: StreamingManager | undefined,
    fileOperationManager: FileOperationManager,
  ) // Dependency injection pattern works well
}
```

**Service Layer Separation**:
- `MemoryBankServiceCore` ‚Üí Core business logic (validated)
- `MemoryBankMCPAdapter` ‚Üí MCP protocol adapter (stable)
- `BaseMCPServer` ‚Üí Common MCP server functionality (reusable)

### Error Boundary Patterns ‚úÖ
```typescript
// Standard pattern across codebase:
const result = await ensureMemoryBankReady(this.memoryBank);
if (isError(result)) {
  return createErrorResponse(result.error, toolName);
}
```

**Mandatory Error Handling**:
- Use `AsyncResult<T, MemoryBankError>` for all async operations
- Implement `ensureMemoryBankReady()` check in all MCP tools
- Use structured error responses with `createErrorResponse()` helper

## Memory Bank File Organization

### Validated File Structure ‚úÖ
```mermaid
memory-bank/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ projectBrief.md      # Hot file - load immediately
‚îÇ   ‚îú‚îÄ‚îÄ productContext.md    # Hot file - load immediately
‚îÇ   ‚îî‚îÄ‚îÄ activeContext.md     # Hot file - load immediately
‚îú‚îÄ‚îÄ progress/
‚îÇ   ‚îú‚îÄ‚îÄ current.md           # Hot file - load immediately
‚îÇ   ‚îú‚îÄ‚îÄ history.md           # Warm file - load on demand
‚îÇ   ‚îî‚îÄ‚îÄ index.md             # Warm file - load on demand
‚îú‚îÄ‚îÄ systemPatterns/
‚îÇ   ‚îú‚îÄ‚îÄ index.md             # Warm file - load on demand
‚îÇ   ‚îú‚îÄ‚îÄ architecture.md      # Warm file - load on demand
‚îÇ   ‚îú‚îÄ‚îÄ patterns.md          # Cold file - chunk if >30KB
‚îÇ   ‚îî‚îÄ‚îÄ scanning.md          # Cold file - chunk if >30KB
‚îî‚îÄ‚îÄ techContext/
    ‚îú‚îÄ‚îÄ index.md             # Warm file - load on demand
    ‚îú‚îÄ‚îÄ stack.md             # Cold file - reference @002-build-system-tooling.mdc
    ‚îú‚îÄ‚îÄ dependencies.md      # Cold file - chunk if >30KB
    ‚îî‚îÄ‚îÄ environment.md       # Cold file - chunk if >30KB
```

### File Access Patterns üîÑ (Roadmap Item)
**Current State**: All files loaded equally via `loadFiles()`
**Target Implementation**:
```typescript
// Tiered loading strategy (planned):
const HOT_FILES = [
  MemoryBankFileType.ProjectBrief,
  MemoryBankFileType.ActiveContext,
  MemoryBankFileType.ProgressCurrent
];

async loadFilesByPriority() {
  // Phase 1: Load hot files immediately
  await this.loadFilesSubset(HOT_FILES);

  // Phase 2: Load warm files on-demand
  await this.loadOnDemand(WARM_FILES);

  // Phase 3: Read cold files on-demand for each access (no streaming)
  await this.loadOnDemand(COLD_FILES);
}
```

### File Size Management ‚ö†Ô∏è
- **Monitoring**: Files >15KB should trigger size warnings
- **Streaming**: Files >30KB should use StreamingManager (infrastructure ready)
- **Chunking**: Memory bank files rarely exceed these limits in practice

> **Note**: Heavy **streaming** layers have been removed, but the **hot/warm/cold** priority model is still valid ‚Äî it now just decides whether files are eagerly loaded (hot), cached lazily (warm), or read fresh each time (cold). No extra buffering or chunking logic is needed for typical file sizes.

## MCP Tool Implementation Patterns ‚úÖ

### Standardized Tool Creation
```typescript
// Proven pattern for all tools:
export const memoryBankTool = createMemoryBankTool(
  memoryBank,
  async (params: ValidatedParams) => {
    // Tool implementation
    return { success: true, data: result };
  },
  "Error context for debugging"
);
```

### Zod Parameter Validation ‚úÖ
```typescript
// Comprehensive validation implemented:
const paramsSchema = z.object({
  fileType: MemoryBankFileTypeSchema,
  content: z.string().min(1),
  relativePath: SafePathSchema.optional()
});

// Usage in tools:
const validatedParams = validateMCPToolParams(toolName, params, paramsSchema);
```

**Validation Requirements**:
- All MCP tools MUST use Zod schemas
- Use `ValidatedMCPParams` type definitions
- Implement proper error transformation via `validateMCPToolParams()`

### Response Standardization ‚úÖ
```typescript
// Consistent response patterns:
return createSuccessResponse(`Operation completed: ${details}`);
return createErrorResponse(error, "Tool operation context");
```

For reasoning strategies and decision-logging templates, see `004-ai-reasoning-strategy.mdc`.

## Memory Bank Service Integration

### Core Service Dependencies ‚úÖ (simplified)
```typescript
// Validated dependency pattern:
class MemoryBankServiceCore {
  constructor(
    private readonly memoryBankPath: string,
    private readonly logger: Logger,
    private readonly cacheManager?: CacheManager,        // Optional performance layer (disabled)
    private readonly streamingManager?: StreamingManager, // Optional large-file handling
    private readonly fileOperationManager: FileOperationManager // Safe I/O
  ) {}
}
```

### Health Checking Implementation ‚úÖ
```typescript
// Structured health reports working well:
async checkHealth(): AsyncResult<string, MemoryBankError> {
  const context = this.createContext();
  const { isHealthy, issues, summary } = await this.performHealthCheck(context);
  return { success: true, data: summary };
}
```

### Configuration Management ‚úÖ
```typescript
// FileOperationContext pattern proven effective:
interface FileOperationContext {
  memoryBankFolder: string;
  logger: Logger;
  fileCache: Map<string, FileCache>;
  cacheStats: LegacyCacheStats;
  streamingManager: StreamingManager;
  fileOperationManager: FileOperationManager;
}
```

## Metadata System Integration

### Implementation Status üß™
**Current State**: Fully implemented but NOT production-ready
- ‚ùå **Tests**: Many mock tests failing, needs debugging
- ‚ùå **Integration**: Not tested in real VSIX builds
- ‚ùå **Validation**: No real-world validation completed

**Available Tools** (when stabilized):
```typescript
// Implemented in MetadataToolRegistrar:
- query-memory-index        // Search with filters, pagination
- validate-memory-file      // Zod schema validation
- rebuild-metadata-index    // Full index rebuilding
- get-metadata-for-file     // Individual file metadata
- get-metadata-index-stats  // Index health monitoring
```

### Metadata Tool Integration Pattern
```typescript
// Enable only when production-ready:
if (config.enableMetadataTools && isProduction) {
  this.metadataToolRegistrar.registerQueryMemoryIndexTool(server);
  // ... other metadata tools
}
```

## Integration Best Practices

### Cross-Module Communication ‚úÖ
```typescript
// Proven message passing patterns:
interface WebviewToExtensionMessage {
  command: string;
  [key: string]: unknown;
}

// Extension ‚Üî Webview communication via postMessage
this.panel.webview.postMessage({
  type: "memoryBankStatus",
  initialized: isInitialized
});
```

### Error Recovery Patterns ‚úÖ
```typescript
// Self-healing implemented and tested:
async loadFileWithTemplate(fileType: MemoryBankFileType) {
  const { content, stats, wasCreated } = await this.createFileFromTemplate(fileType);
  if (wasCreated) {
    this.logger.info(`Self-healing: Created missing file ${fileType}`);
  }
  return { content, stats };
}
```

### Security Integration ‚úÖ
```typescript
// Path validation proven effective:
function validateAndConstructFilePath(memoryBankFolder: string, fileType: string): string {
  const fullPath = path.join(memoryBankFolder, fileType);
  if (!fullPath.startsWith(path.resolve(memoryBankFolder))) {
    throw new MemoryBankError("Path traversal detected", "SECURITY_ERROR");
  }
  return fullPath;
}
```

## Performance Integration

### Streaming Manager Integration ‚úÖ
```typescript
// Size-based strategy selection working well:
class StreamingManager {
  private readonly sizeThreshold = 1024 * 1024; // 1MB

  async readFile(filePath: string): Promise<Result<StreamingResult, FileError>> {
    const stats = await this.getFileStats(filePath);
    const strategy = stats.size >= this.sizeThreshold ? "streaming" : "normal";
    return this.executeStrategy(strategy, filePath, stats);
  }
}
```

### Cache Integration ‚úÖ
```typescript
// Cache management patterns proven stable:
class CacheManager {
  getCachedContent(filePath: string, stats: Stats): string | null {
    const entry = this.cache.get(filePath);
    return entry && !this.isExpired(entry, stats) ? entry.content : null;
  }
}
```

## Testing Integration Patterns

### Mock Patterns ‚úÖ
```typescript
// Effective patterns for complex scenarios:
vi.hoisted(() => {
  // Module-level mocking for MCP SDK components
  return { mockServer, mockTransport };
});

// Filesystem mocking with path validation:
const mockFileManager = createMockFileOperationManager();
mockFileManager.readFileWithRetry = vi.fn().mockResolvedValue({
  success: true,
  data: "test content"
});
```

### Integration Testing Requirements
- ‚úÖ **MCP Server**: Startup, shutdown, tool registration
- ‚ö†Ô∏è **End-to-End**: Memory bank operations through full stack (needs work)
- ‚ùå **VSIX**: Extension packaging and installation testing (not done)
- ‚ùå **Real Debugging**: Production debugging workflows (needed)
- **Unified Testing**: Single vitest config with projects pattern eliminates testing fragmentation

## Development Workflow

### Build Integration ‚úÖ
```bash
# Validated build commands:
pnpm build           # Extension + MCP server compilation
pnpm test           # Parallel testing across workspaces
pnpm package        # VSIX packaging (not production-tested)
```

### Error Boundary Testing
```typescript
// Test all error conditions:
- Memory bank initialization failures
- File operation errors with retry logic
- MCP tool parameter validation failures
- Network transport error recovery
```

## Cross-References

- **@001-vsix-extension.mdc**: Webview integration, security patterns, VS Code lifecycle
- **@002-build-system-tooling.mdc**: TypeScript compilation, testing frameworks, build optimization
- **techContext/stack.md**: Technology choices, dependency rationale, performance decisions

---

*Reflects actual implementation state as of 2025-06-07. Rules validated against production codebase.*
*Phase 4 Updates: Prepared for unified testing approach and simplified file organization.*
*Last updated: 2025-06-07*
